---
layout: post
title:  "Graph Theory: Javascript Implementation"
date:   2015-01-19 3:21:43
excerpt: "My take on implementing a graph."
categories: graph_analysis
codeType: ["javascript"]
js: ["d3/d3"]
jsLink: ["http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"]
---
<p>In graph theory, a <a href="http://www.wikiwand.com/en/Graph_(mathematics)">graph</a> is a representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by mathematical abstractions called vertices (or nodes), and the links that connect some pairs of vertices are called edges (or links).<br> Usually, a graph is represented as a set of dots for the vertices, joined by lines or curves for the edges.</p>
<p>Here is an example of a graph using <a href="http://d3js.org/">d3.js</a>:</p>
<section id="CanvasSection1"></section>
<p>A graph may be directed or non-directed and it can represent many things, for example, if nodes represent cities, edges may represent a route between a pair of cities. Nodes and edges may have additional variables, such as a <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)#Weighted_graph">weight</a>, flow, maximum flow, minimum flow, etc. depending on the problem.</p>
<p>I used javascript for this software and more specifically I programmed using the <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#factorypatternjavascript">Factory Pattern</a> due to how it feels like the <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented Programming</a> paradigm but with some tweaks.</p>
<p>I'll by start explaining how I implemented each class and what does each parameter and variable do: </p>
<ul>
    <li><h1>Vertex</h1>
        <p>A vertex receives a single variable as a parameter and contains 7 variables:</p>
<pre><code data-language="javascript">function Vertex(n){
    this.name = n + "";
    this.adjacents = [];
    this.distance = 0;
    this.maxFlow = "none";
    this.minFlow = 0;
    this.tag = { key: Infinity, parent: null, edge: null };
    this.color = -1;
};</code></pre>
        <ul>
            <li>
                <h4>Parameters:</h4>
                <ul>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Vertex( n ) </code></pre>
                        <p>This is the name of the vertex we're creating which will be used to identify it.</p>
                    </li>
                </ul>
            </li>
            <li>
                <h4>Variables:</h4>
                <ul>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.name = n + ""; </code></pre>
                        <p>Here I store the name of the vertex, this is trivial since we need a way to find and identify the vertex. I concatenate an empty string to transform the object into a String type in case it receives a Number type object.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.adjacents = [ ]; </code></pre>
                        <p>This variable stores any edges that are connected to this vertex, be it the sink or the source of the edge.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.distance = 0; </code></pre>
                        <p>This counts the distance from the source node of an algorithm to this node. Depending on the algorithm, this can stay on 0.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.maxFlow = "none"; </code></pre>
                        <p>Sets a limit fot the amount of flow that can flow through this node. The default value is <b>Infinity</b>.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.minFlow = "none"; </code></pre>
                        <p>Sets a minimum amount of flow that must flow through this node. The default value is 0.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.tag = { key: Infinity, parent: null, edge: null }; </code></pre>
                        <p>A tag object is needed for certain algorithms such as Dijkstra's or Prim's. The key variable is used to contain a flow value from a parent or a sum total. The parent variable is a reference to the previous node in the path of the current node. Finally, the edge variable is a reference to the edge that connects the current node to its parent.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.color = -1; </code></pre>
                        <p>The color variable is used as a flag that changes value depending on the algorithm, usually to see if the algorithm already explored this node. This doesn't determine the actual color of the vertex.</p>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    
    
    <li><h1>Edge</h1>
        <p>An edge may receive 6 variables as parameters and contains 8 variables:</p>
<pre><code data-language="javascript">function Edge(source,sink,cost,flow,maxFlow,minFlow){
    this.source = source;
    this.sink = sink;
    this.cost = cost || 0;
    this.minFlow = !minFlow || minFlow < 0 ? 0 : minFlow;
    this.maxFlow = !maxFlow ? Infinity : maxFlow < this.minFlow ? this.minFlow : maxFlow;
    this.flow = !flow || flow < 0 ? 0 : flow > this.maxFlow ? this.maxFlow : flow;
    this.redge = null;
    this.fake = false;  
    this.color = -1;    
};</code></pre>
        <ul>
            <li>
                <h4>Parameters:</h4>
                <ul>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( source, ... ) </code></pre>
                        <p>The edge's tail or 'from' variable. </p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( ..., sink, ... ) </code></pre>
                        <p>The edge's head or 'to' variable.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( ..., cost, ... ) </code></pre>
                        <p>The cost or weight variable of an edge. This cost may have different meanings, usually it is how much you would be spending while traveling through an edge. This variable is the target of many of the algorithms that aim to find the minimum cost while traveling through all the nodes of the graph.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( ..., flow, ... ) </code></pre>
                        <p>Flow is an abstraction of units that travel through an edge. Each flow unit has may have a cost which equals an edge's cost variable.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( ..., maxFlow, ... ) </code></pre>
                        <p>A limit on how much flow may travel through an edge.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > function Edge( ..., minFlow ) </code></pre>
                        <p>A minimum number of flow units that must travel through an edge. In case that a minimum flow cannot be satisfied, there won't be a solution for any algorithm.</p>
                    </li>
                </ul>
            </li>
            <li>
                <h4>Variables:</h4>
                <ul>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.source = source; </code></pre>
                        <p>A reference to the tail node is stored here.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.sink = sink; </code></pre>
                        <p>A reference to the head node is stored here.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.cost = cost || 0; </code></pre>
                        <p>The cost of going through this link. If no value is received it is set to a default value of <b>0</b>.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.minFlow = !minFlow || minFlow &lt; 0 ? 0 &#58; minFlow; </code></pre>
                        <p>The number of flow units that must travel through this edge, disregarding cost or anything else. If no value is set or the minimum flow is lesser than 0, a default value of <b>0</b> is set.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.maxFlow = !maxFlow ? Infinity &#58; maxFlow &lt; this.minFlow ? this.minFlow &#58; maxFlow; </code></pre>
                        <p>The edge's maximum flow limit is stored here. If the value received is undefined or equals 0, <b>Infinity</b> will be assigned and in case the value received is lesser than <code> minFlow </code>,  the value assigned will be equals to <code> minFlow </code>.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.flow = !flow || flow &lt; 0 ? 0 &#58; flow &gt; this.maxFlow ? this.maxFlow &#58; flow; </code></pre>
                        <p>The number of units currently flowing through this edge, the total cost of going through the edge is relative to the current flow. The default value of this variable is <b>0</b>. In case the value exceeds <code> maxFlow </code>, it will be set to the limit's value.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.redge = null; </code></pre>
                        <p>Whenever an edge E = (x, y) is created, a new return&#45;edge (redge) E' = (y, x) is created too and is pushed to node y's adjacents array. The purpose of this is to have a reference to every edge that is pointing to node y and to have an easy way of exploring a graph in case you need to do a directed or undirected search; In case of an directed search redges are simply ignored.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.fake = false; </code></pre>
                        <p>If an edge's fake value is set to <b>true</b>, it means that it is a redge and will be ignored on directed graphs.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.color = &#45;1; </code></pre>
                        <p>Finally, the color variable determines what edges do the algorithms consider on its search, be it a path or a tree. On a value of <b>&#45;1</b> the edge won't be colored, else, its value will be <b>blue</b> and it will be colored when it is drawn.</p>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>

<ul>
    <li><h1>Graph</h1>
        <p>And last but not least, a graph simply has 4 variables:</p>
<pre><code data-language="javascript">function Graph(){
    this.vertexList = [ ];
    this.edgeList = [ ];
    this.directed = true;
    this.matrix = [ ];
};</code></pre>
        <ul>
            <li>
                <h4>Variables:</h4>
                <ul>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.vertexList = [ ]; </code></pre>
                        <p>This variable stores a reference to every single node.</p>                    
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.edgeList = [ ]; </code></pre>
                        <p>This array variable stores a reference to every edge whose fake variable is set to <b>false</b>.</p>                    
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.directed = true; </code></pre>
                        <p>This boolean variable determines if redges should be ignored or not, depending on the algorithm sometimes this will always be true.</p>
                    </li>
                    <li>
                        <pre class="single"><code data-language="javascript" > this.matrix = [ ]; </code></pre>
                        <p>Lastly, this array stores the adjacency matrix of the graph.</p>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h2>Bam!!</h2>
<p> There it is, I hope someone finds this useful someday.<br>I will continue graph theory stuff next with my implementation of a Breadth-first search but it will take me a couple weeks since I'll be participating in the <a href="http://globalgamejam.org/">Global Game Jam</a> in Guadalajara, México with my friends Rami and Berry this Friday. My efforts this week will be 100% focused on creating games on Unity3D so I can be ready for the event, maybe I'll upload one or two of the games I make.</p>
<p>This post's song is <a href="https://www.youtube.com/watch?v=tjms8l15_uM">Vuelve en la Mañana by Insite</a> directly from Mexicali, México.</p>
<p class="note">**Note! Most of the definition of a graph was quoted from Wikipedia, don't hate me!</p>

<script>
    var w = $("#CanvasSection1").width(),
        h = 300;
    var svg = d3.select("#CanvasSection1")
            .append("svg:svg")
            .attr("width", w)
            .attr("height", h)
            .attr("id", "svg")
            .attr("pointer-events", "all")
            .attr("viewBox", "0 0 " + w + " " + h);



    var data = { nodes: 
       [ { name: 'A' },
         { name: 'D' },
         { name: 'E' },
         { name: 'B' },
         { name: 'C' },
         { name: 'F' },],
      links: 
       [ { source: 0,
           target: 1,
           cost: '$0',
           min: 2,
           flow: 18,
           max: 18,
           color: 'link' },
         { source: 0,
           target: 2,
           cost: '$0',
           min: 0,
           flow: 15,
           max: 15,
           color: 'link' },
         { source: 3,
           target: 1,
           cost: '$0',
           min: 0,
           flow: 23,
           max: 23,
           color: 'link' },
         { source: 4,
           target: 5,
           cost: '$0',
           min: 0,
           flow: 4,
           max: 14,
           color: 'link' },
         { source: 4,
           target: 2,
           cost: '$0',
           min: 0,
           flow: 2,
           max: 21,
           color: 'link' },
         { source: 1,
           target: 5,
           cost: '$0',
           min: 0,
           flow: 0,
           max: 28,
           color: 'link' },
         { source: 1,
           target: 4,
           cost: '$0',
           min: 0,
           flow: 0,
           max: 28,
           color: 'link' },
     ] };

    var colorScale3 = d3.scale.linear()
        .domain([0,data.nodes.length])
        .interpolate(d3.interpolateHcl)
        .range(["#0092d1","#b2b20a"]);

    var force = d3.layout.force()
        .nodes(data.nodes)
        .links(data.links)
        .size([w, h])
        .linkDistance(40) //140
        .charge(-1500)
        .gravity(.2)
        .on("tick", tick)
        .start();

    svg.append("rect") //just the background, nothing else;
        .attr("width", w)
        .attr("height", h)
        .attr("rx",7)
        .attr("ry",7)
        .attr("class", "bg");

//    svg.append("svg:defs").selectAll("marker")
//        .data(["end"])
//      .enter().append("svg:marker")    
//        .attr("id", String)
//        .attr("viewBox", "0 -5 10 10")
//        .attr("refX", 20.5)
//        .attr("refY", -2.04)
//        .attr("markerWidth", 8)
//        .attr("markerHeight", 8)
//        .attr("orient", "auto")
//      .append("svg:path")
//        .attr("d", "M0,-7L12,0L0,7");
      //////////Arrows!!
    var path = svg.append("svg:g").selectAll("path")
        .data(force.links())
      .enter().append("svg:path")
        .attr("id",function(d,i) { return "linkId_" + i; })
        .attr({//"class":"link",
              "class":function(d,i){
                      return d.color;  
              }
              ,"marker-end": "url(#end)"
        }); //Append arrow.


//    var linktext = svg.append("svg:g")
//        .selectAll("g.linklabelholder")
//        .data(force.links());
//
//        linktext.enter().append("g").attr("class", "linklabelholder")
//         .append("text")
//         .attr("class", "linklabel")
//         .attr("x", "50")
//         .attr("y", "-20")
//         .append("textPath")
//        .attr("xlink:href",function(d,i) { return "#linkId_" + i;})
//         .text(function(d) { 
//           return d.cost+ "["+d.min+","+d.flow+","+d.max+"]";  //+ "["+d.minFlow+","+d.flow+","d.maxFlow+"]";
//         });

    var node = svg.selectAll(".node")
        .data(force.nodes())
      .enter().append("g")//append node group!!
        .attr("class","node")
        .call(force.drag);

        node.append("circle")
        .attr({
              r:10,
              fill: function(d,i){
                return colorScale3(i);  
              },
              stroke: "#c9c9c9", "stroke-width": 1.32
            });

        node.append("text")
            .attr({
              "alignment-baseline": "middle"
              ,"text-anchor": "middle"
          }).text(function(d){return d.name});

    function tick(){
      path.attr("d", function(d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" + 
                d.source.x + "," + 
                d.source.y + "A" + 
                dr + "," + dr + " 0 0,1 " + 
                d.target.x + "," + 
                d.target.y;
        });
        node.attr("transform", function(d,i) { 
                return "translate(" + d.x + "," + d.y + ")"; });
    }
</script>
